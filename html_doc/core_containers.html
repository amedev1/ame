<!DOCTYPE html>
<!-- Generated by ame util library - using PrismJS 1.20.0 -->
<html>
<head>
	<meta charset="UTF-8">
	<title>Another Memory Ends</title>
	<link rel="stylesheet" type="text/css" href="../CSS/docgen_style.css">
	<link rel="stylesheet" type="text/css" href="../CSS/prism.css">
</head>
<body>
	<script src="../JS/prism.js">
	</script>
	<h1>containers</h1>
	<br>
	<p>
		linked list<br>
		dbuffer: dynamic buffer (based on Sean Barrett's stretchy buffer https:github.com/nothings/stb/blob/master/stretchy_buffer.h)<br>
		comes with a fixed version (fbuffer)<br>
		used as underlying mechanism for vector, stack, queue
	</p>
	<br>
	<section class="main">
		<h2 id="core_containers_c_list_clear">c_list_clear</h2>
		<pre><code class="language-c">#define c_list_clear(list)             c_list_internal_clear(&(list))</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>clear linked list</description>
		<h2 id="core_containers_c_list_push">c_list_push</h2>
		<pre><code class="language-c">#define c_list_push(list, value)       (memcpy(c_list_internal_push(&(list), sizeof(value)), &(v), sizeof(value)))</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>push element at the end of linked list</description>
		<h2 id="core_containers_c_list_push_front">c_list_push_front</h2>
		<pre><code class="language-c">#define c_list_push_front(list, value) (memcpy(c_list_internal_push_front(&(list), sizeof(value)), &value, sizeof(value)))</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>push element at the start of linked list</description>
		<h2 id="core_containers_c_list_pop">c_list_pop</h2>
		<pre><code class="language-c">#define c_list_pop(list)               c_list_internal_pop(&(list))</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>remove linked list last element</description>
		<h2 id="core_containers_c_list_pop_front">c_list_pop_front</h2>
		<pre><code class="language-c">#define c_list_pop_front(list)         c_list_internal_pop_front(&(list))</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>remove linked list first element</description>
		<h2 id="core_containers_c_list_empty">c_list_empty</h2>
		<pre><code class="language-c">#define c_list_empty(list)             ((list) ? true : false)</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>check if linked list is empty</description>
		<h2 id="core_containers_c_list_get_ptr">c_list_get_ptr</h2>
		<pre><code class="language-c">#define c_list_get_ptr(list, value)    memcpy(&(value), &(list->data), sizeof(value))</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>get pointer to current linked list element</description>
		<h2 id="core_containers_c_list_get">c_list_get</h2>
		<pre><code class="language-c">#define c_list_get(list, value)        memcpy(&(value), list->data, sizeof(value))</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>get current linked list element</description>
		<h2 id="core_containers_List">List</h2>
		<pre><code class="language-c">typedef struct List {
  struct List *next;
  void        *data;
} List;
</code></pre>
		<description><b>type:</b> <i>C struct</i></description>
		<br>
		<description><b>description: </b>linked list node</description>
		<h2 id="core_containers_c_list_internal_clear">c_list_internal_clear</h2>
		<pre><code class="language-c">void  c_list_internal_clear(List** list);</code></pre>
		<description><b>type:</b> <i>C function</i></description>
		<br>
		<description><b>description: </b>internal function to clear linked list</description>
		<h2 id="core_containers_c_list_internal_push">c_list_internal_push</h2>
		<pre><code class="language-c">void *c_list_internal_push(List** list, size_t size);</code></pre>
		<description><b>type:</b> <i>C function</i></description>
		<br>
		<description><b>description: </b>internal function to push new element at the end of list</description>
		<h2 id="core_containers_c_list_internal_push_front">c_list_internal_push_front</h2>
		<pre><code class="language-c">void *c_list_internal_push_front(List** list, size_t size);</code></pre>
		<description><b>type:</b> <i>C function</i></description>
		<br>
		<description><b>description: </b>internal function to add new element at the front of the list</description>
		<h2 id="core_containers_c_list_internal_pop">c_list_internal_pop</h2>
		<pre><code class="language-c">void  c_list_internal_pop(List** list);</code></pre>
		<description><b>type:</b> <i>C function</i></description>
		<br>
		<description><b>description: </b>internal function to pop list last element</description>
		<h2 id="core_containers_c_list_internal_pop_front">c_list_internal_pop_front</h2>
		<pre><code class="language-c">void  c_list_internal_pop_front(List** list);</code></pre>
		<description><b>type:</b> <i>C function</i></description>
		<br>
		<description><b>description: </b>internal function to remove list first element</description>
		<h2 id="core_containers_dbuffer_free">dbuffer_free</h2>
		<pre><code class="language-c">#define dbuffer_free(p)    ((p) ? (c_free(dbuffer_raw(p)), *((void **)&(p)) = 0) : 0)</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>clear dynamic buffer memory</description>
		<h2 id="core_containers_dbuffer_push">dbuffer_push</h2>
		<pre><code class="language-c">#define dbuffer_push(p, v) (dbuffer_maybe_grow(p,1), (p)[dbuffer_length(p)++] = (v))</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>push value to dynamic buffer</description>
		<h2 id="core_containers_dbuffer_count">dbuffer_count</h2>
		<pre><code class="language-c">#define dbuffer_count(p)   ((p) ? dbuffer_length(p) : 0)</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>count elements in dynamic buffer</description>
		<h2 id="core_containers_dbuffer_add">dbuffer_add</h2>
		<pre><code class="language-c">#define dbuffer_add(p, n)  (dbuffer_maybe_grow(p,n), dbuffer_length(p)+=(n), &(p)[dbuffer_length(p)-(n)])</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>add element in dynamic buffer and return pointer</description>
		<h2 id="core_containers_dbuffer_last">dbuffer_last</h2>
		<pre><code class="language-c">#define dbuffer_last(p)    ((p)[dbuffer_length(p)-1])</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>last element of dynamic buffer</description>
		<h2 id="core_containers_dbuffer_pop">dbuffer_pop</h2>
		<pre><code class="language-c">#define dbuffer_pop(p)     ((p) ? (dbuffer_length(p) ? dbuffer_length(p)-- : 0) : 0)</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>remove last element of dynamic buffer</description>
		<h2 id="core_containers_dbuffer_get">dbuffer_get</h2>
		<pre><code class="language-c">#define dbuffer_get(p, n)  ((p) ? (n < dbuffer_length(p) ? &(p)[n] : 0) : 0)</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>get pointer to element of dynamic buffer</description>
		<h2 id="core_containers_dbuffer_reset">dbuffer_reset</h2>
		<pre><code class="language-c">#define dbuffer_reset(p)   ((p) ? (dbuffer_length(p) = 0) : 0)</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>reset dynamic buffer</description>
		<h2 id="core_containers_dbuffer_insert">dbuffer_insert</h2>
		<pre><code class="language-c">#define dbuffer_insert(p, n, v) (*((void **)&(p)) = dbuffer_insert_call((p), (n), sizeof(*(p))), (p)[n] = (v))</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>insert element at index in dynamic buffer</description>
		<h2 id="core_containers_dbuffer_add_at">dbuffer_add_at</h2>
		<pre><code class="language-c">#define dbuffer_add_at(p, n)    (*((void **)&(p)) = dbuffer_insert_call((p), (n), sizeof(*(p)))))</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>add element at index in dynamic buffer and return pointer</description>
		<h2 id="core_containers_dbuffer_remove">dbuffer_remove</h2>
		<pre><code class="language-c">#define dbuffer_remove(p, n)    (c_dbuffer_internal_remove((p), (n), sizeof(*(p))))</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>remove element at index in dynamic buffer</description>
		<h2 id="core_containers_dbuffer_raw">dbuffer_raw</h2>
		<pre><code class="language-c">#define dbuffer_raw(p)   ((uint *) (void *) (p) - 2)</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>start address of dynamic buffer memory</description>
		<h2 id="core_containers_dbuffer_size">dbuffer_size</h2>
		<pre><code class="language-c">#define dbuffer_size(p)   dbuffer_raw(p)[0]</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>size of dynamic buffer (capacity)</description>
		<h2 id="core_containers_dbuffer_length">dbuffer_length</h2>
		<pre><code class="language-c">#define dbuffer_length(p) dbuffer_raw(p)[1]</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>length of dynamic buffer (current count)</description>
		<h2 id="core_containers_dbuffer_need_grow">dbuffer_need_grow</h2>
		<pre><code class="language-c">#define dbuffer_need_grow(p, n)  ((p)==0 || dbuffer_length(p)+(n) >= dbuffer_size(p))</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>check if dynamic buffer needs to grow</description>
		<h2 id="core_containers_dbuffer_maybe_grow">dbuffer_maybe_grow</h2>
		<pre><code class="language-c">#define dbuffer_maybe_grow(p, n) (dbuffer_need_grow(p,(n)) ? dbuffer_grow(p,n) : 0)</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>grow if dynamic buffers needs to grow</description>
		<h2 id="core_containers_dbuffer_grow">dbuffer_grow</h2>
		<pre><code class="language-c">#define dbuffer_grow(p, n)       (*((void **)&(p)) = dbuffer_grow_call((p), (n), sizeof(*(p))))</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>grow dynamic buffer</description>
		<h2 id="core_containers_dbuffer_grow_call">dbuffer_grow_call</h2>
		<pre><code class="language-c">#define dbuffer_grow_call(a, i, s) c_dbuffer_internal_grow_debug(a, i, s, __FILENAME__, __LINE__)</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>call to grow dynamic buffer, different version with debug memory</description>
		<h2 id="core_containers_dbuffer_insert_call">dbuffer_insert_call</h2>
		<pre><code class="language-c">#define dbuffer_insert_call(a, i, s) c_dbuffer_internal_insert_debug(a, i, s, __FILENAME__, __LINE__)</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>call to insert in dynamic buffer, different version with debug memory</description>
		<h2 id="core_containers_dbuffer_grow_call">dbuffer_grow_call</h2>
		<pre><code class="language-c">#define dbuffer_grow_call(a, i, s) c_dbuffer_internal_grow(a, i, s)</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<h2 id="core_containers_dbuffer_insert_call">dbuffer_insert_call</h2>
		<pre><code class="language-c">#define dbuffer_insert_call(a, i, s) c_dbuffer_internal_insert(a, i, s)</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<h2 id="core_containers_c_dbuffer_internal_grow_debug">c_dbuffer_internal_grow_debug</h2>
		<pre><code class="language-c">void *c_dbuffer_internal_grow_debug(void *array, uint increment, size_t item_size, char *filename, uint line);</code></pre>
		<description><b>type:</b> <i>C function</i></description>
		<br>
		<description><b>description: </b>internal function to grow dynamic buffer - debug memory version</description>
		<h2 id="core_containers_c_dbuffer_internal_insert_debug">c_dbuffer_internal_insert_debug</h2>
		<pre><code class="language-c">void *c_dbuffer_internal_insert_debug(void *array, uint index, size_t item_size, char *filename, uint line);</code></pre>
		<description><b>type:</b> <i>C function</i></description>
		<h2 id="core_containers_c_dbuffer_internal_grow">c_dbuffer_internal_grow</h2>
		<pre><code class="language-c">void *c_dbuffer_internal_grow(void *array, uint increment, size_t item_size);</code></pre>
		<description><b>type:</b> <i>C function</i></description>
		<br>
		<description><b>description: </b>internal function to grow dynamic buffer</description>
		<h2 id="core_containers_c_dbuffer_internal_insert">c_dbuffer_internal_insert</h2>
		<pre><code class="language-c">void *c_dbuffer_internal_insert(void *array, uint index, size_t item_size);</code></pre>
		<description><b>type:</b> <i>C function</i></description>
		<br>
		<description><b>description: </b>internal function to insert element in dynamic buffer</description>
		<h2 id="core_containers_c_dbuffer_internal_remove">c_dbuffer_internal_remove</h2>
		<pre><code class="language-c">void  c_dbuffer_internal_remove(void *array, uint index, size_t item_size);</code></pre>
		<description><b>type:</b> <i>C function</i></description>
		<br>
		<description><b>description: </b>internal function to remove element in dynamic buffer</description>
		<h2 id="core_containers_c_vector_push">c_vector_push</h2>
		<pre><code class="language-c">#define c_vector_push   dbuffer_push</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>push element in vector</description>
		<h2 id="core_containers_c_vector_pop">c_vector_pop</h2>
		<pre><code class="language-c">#define c_vector_pop    dbuffer_pop</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>pop vector last element</description>
		<h2 id="core_containers_c_vector_insert">c_vector_insert</h2>
		<pre><code class="language-c">#define c_vector_insert dbuffer_insert</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>insert element in vector</description>
		<h2 id="core_containers_c_vector_add_at">c_vector_add_at</h2>
		<pre><code class="language-c">#define c_vector_add_at dbuffer_add_at</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>add element in vector at index and return pointer</description>
		<h2 id="core_containers_c_vector_remove">c_vector_remove</h2>
		<pre><code class="language-c">#define c_vector_remove dbuffer_remove</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>remove element at index in vector</description>
		<h2 id="core_containers_c_vector_clear">c_vector_clear</h2>
		<pre><code class="language-c">#define c_vector_clear  dbuffer_free</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>clear all vector elements</description>
		<h2 id="core_containers_c_vector_count">c_vector_count</h2>
		<pre><code class="language-c">#define c_vector_count  dbuffer_count</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>return number of vector elements</description>
		<h2 id="core_containers_c_vector_add">c_vector_add</h2>
		<pre><code class="language-c">#define c_vector_add    dbuffer_add</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>add element in vector and return pointer</description>
		<h2 id="core_containers_c_vector_get">c_vector_get</h2>
		<pre><code class="language-c">#define c_vector_get    dbuffer_get</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>get pointer of vector element at index</description>
		<h2 id="core_containers_c_vector_reset">c_vector_reset</h2>
		<pre><code class="language-c">#define c_vector_reset  dbuffer_reset</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>reset vector</description>
		<h2 id="core_containers_c_stack_add">c_stack_add</h2>
		<pre><code class="language-c">#define c_stack_add(s)   dbuffer_add(s, 1)</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>push element on stack and return pointer</description>
		<h2 id="core_containers_c_stack_push">c_stack_push</h2>
		<pre><code class="language-c">#define c_stack_push     dbuffer_push</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>push element on stack</description>
		<h2 id="core_containers_c_stack_pop">c_stack_pop</h2>
		<pre><code class="language-c">#define c_stack_pop      dbuffer_pop</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>pop stack last element</description>
		<h2 id="core_containers_c_stack_empty">c_stack_empty</h2>
		<pre><code class="language-c">#define c_stack_empty(s) (dbuffer_count(s) == 0)</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>check if stack is empty</description>
		<h2 id="core_containers_c_stack_clear">c_stack_clear</h2>
		<pre><code class="language-c">#define c_stack_clear    dbuffer_free</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>clear all elements in stack</description>
		<h2 id="core_containers_c_stack_reset">c_stack_reset</h2>
		<pre><code class="language-c">#define c_stack_reset    dbuffer_reset</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>reset vector</description>
		<h2 id="core_containers_c_stack_last">c_stack_last</h2>
		<pre><code class="language-c">#define c_stack_last(s)  dbuffer_get(s, dbuffer_count(s) - 1)</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>get last element of fixed stack</description>
		<h2 id="core_containers_c_queue_enqueue">c_queue_enqueue</h2>
		<pre><code class="language-c">#define c_queue_enqueue    dbuffer_push</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>enqueue element in queue</description>
		<h2 id="core_containers_c_queue_add">c_queue_add</h2>
		<pre><code class="language-c">#define c_queue_add(q)     dbuffer_add(q, 1)</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>enqueue element in queue and return pointer</description>
		<h2 id="core_containers_c_queue_dequeue">c_queue_dequeue</h2>
		<pre><code class="language-c">#define c_queue_dequeue(q) dbuffer_remove(q, 0)</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>dequeue queue first element</description>
		<h2 id="core_containers_c_queue_empty">c_queue_empty</h2>
		<pre><code class="language-c">#define c_queue_empty(q)   (dbuffer_count(q) == 0)</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>check if queue is empty</description>
		<h2 id="core_containers_c_queue_clear">c_queue_clear</h2>
		<pre><code class="language-c">#define c_queue_clear      dbuffer_free</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>clear all elements in queue</description>
		<h2 id="core_containers_c_queue_reset">c_queue_reset</h2>
		<pre><code class="language-c">#define c_queue_reset      dbuffer_reset</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>reset vector</description>
		<h2 id="core_containers_fbuffer_struct">fbuffer_struct</h2>
		<pre><code class="language-c">#define fbuffer_struct(a, t, n) struct { uint size; uint length; t array[n]; } a</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>declare a fixed buffer as a struct</description>
		<h2 id="core_containers_fbuffer_init">fbuffer_init</h2>
		<pre><code class="language-c">#define fbuffer_init(n) { n , 0 }</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>initialize a fixed buffer</description>
		<h2 id="core_containers_fbuffer_var">fbuffer_var</h2>
		<pre><code class="language-c">#define fbuffer_var(a, t, n) fbuffer_struct(fbuffer_name(a), t, n) = fbuffer_init(n); t* a = fbuffer_name(a).data</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>declare & initialize a fixed buffer on the stack</description>
		<h2 id="core_containers_fbuffer_push">fbuffer_push</h2>
		<pre><code class="language-c">#define fbuffer_push(a, v) (fbuffer_length(a) < fbuffer_size(a) ? a[fbuffer_length(a)++] = v : 0)</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>push value in fixed buffer</description>
		<h2 id="core_containers_fbuffer_count">fbuffer_count</h2>
		<pre><code class="language-c">#define fbuffer_count(a)   fbuffer_length(a)</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>return number of elements in fixed buffer</description>
		<h2 id="core_containers_fbuffer_add">fbuffer_add</h2>
		<pre><code class="language-c">#define fbuffer_add(a, n)  (fbuffer_length(a) < fbuffer_size(a) ? fbuffer_length(a)+=(n), &(a)[fbuffer_length(a)-(n)] : NULL)</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>add element to fixed buffer & return pointer</description>
		<h2 id="core_containers_fbuffer_last">fbuffer_last</h2>
		<pre><code class="language-c">#define fbuffer_last(a)    ((a)[fbuffer_length(a)-1])</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>get last element of fixed buffer</description>
		<h2 id="core_containers_fbuffer_pop">fbuffer_pop</h2>
		<pre><code class="language-c">#define fbuffer_pop(a)     (fbuffer_length(a) ? fbuffer_length(a)-- : 0)</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>remove last element of fixed buffer</description>
		<h2 id="core_containers_fbuffer_free">fbuffer_free</h2>
		<pre><code class="language-c">#define fbuffer_free(a)    fbuffer_length(a) = 0</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>clear fixed buffer</description>
		<h2 id="core_containers_fbuffer_get">fbuffer_get</h2>
		<pre><code class="language-c">#define fbuffer_get(a, n)  (n < fbuffer_length(a) ? &(a)[n] : 0)</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>get pointer to element of fixed buffer</description>
		<h2 id="core_containers_fbuffer_reset">fbuffer_reset</h2>
		<pre><code class="language-c">#define fbuffer_reset(a)   (fbuffer_length(a) = 0)</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>reset fixed buffer</description>
		<h2 id="core_containers_fbuffer_insert">fbuffer_insert</h2>
		<pre><code class="language-c">#define fbuffer_insert(a, n, v) (c_fbuffer_internal_insert((a), (n), sizeof(*(a)), (a)[n] = (v))</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>insert element in fixed buffer</description>
		<h2 id="core_containers_fbuffer_add_at">fbuffer_add_at</h2>
		<pre><code class="language-c">#define fbuffer_add_at(a, n)    (c_fbuffer_internal_insert((a), (n), sizeof(*(a))))</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>add element in fixed buffer at index</description>
		<h2 id="core_containers_fbuffer_remove">fbuffer_remove</h2>
		<pre><code class="language-c">#define fbuffer_remove(a, n)    (c_fbuffer_internal_remove((a), (n), sizeof(*(a))))</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>remove element in fixed buffer</description>
		<h2 id="core_containers_fbuffer_name">fbuffer_name</h2>
		<pre><code class="language-c">#define fbuffer_name(a)   CONCAT2(_fixed_buffer_, a)</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>name of fixed buffer struct when created on the stack</description>
		<h2 id="core_containers_fbuffer_raw">fbuffer_raw</h2>
		<pre><code class="language-c">#define fbuffer_raw(a)    ((uint *) (void *) (a) - 2)</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>starting address of fixed buffer struct</description>
		<h2 id="core_containers_fbuffer_size">fbuffer_size</h2>
		<pre><code class="language-c">#define fbuffer_size(a)   fbuffer_raw(a)[0]</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>size of fixed buffer (capacity)</description>
		<h2 id="core_containers_fbuffer_length">fbuffer_length</h2>
		<pre><code class="language-c">#define fbuffer_length(a) fbuffer_raw(a)[1]</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>length of fixed buffer (current count)</description>
		<h2 id="core_containers_c_fbuffer_internal_insert">c_fbuffer_internal_insert</h2>
		<pre><code class="language-c">void c_fbuffer_internal_insert(void *array, uint index, size_t item_size);</code></pre>
		<description><b>type:</b> <i>C function</i></description>
		<br>
		<description><b>description: </b>internal function to insert element in fixed buffer</description>
		<h2 id="core_containers_c_fbuffer_internal_remove">c_fbuffer_internal_remove</h2>
		<pre><code class="language-c">void c_fbuffer_internal_remove(void *array, uint index, size_t item_size);</code></pre>
		<description><b>type:</b> <i>C function</i></description>
		<br>
		<description><b>description: </b>internal function to remove element in fixed buffer</description>
		<h2 id="core_containers_fvector_struct">fvector_struct</h2>
		<pre><code class="language-c">#define fvector_struct   fbuffer_struct</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>declare a fixed vector struct</description>
		<h2 id="core_containers_fvector_init">fvector_init</h2>
		<pre><code class="language-c">#define fvector_init     fbuffer_init</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>initialize a fixed vector</description>
		<h2 id="core_containers_fvector_var">fvector_var</h2>
		<pre><code class="language-c">#define fvector_var      fbuffer_var</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>declare & initialize a fixed vector on the stack</description>
		<h2 id="core_containers_c_fvector_push">c_fvector_push</h2>
		<pre><code class="language-c">#define c_fvector_push   fbuffer_push</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>push an element in fixed vector</description>
		<h2 id="core_containers_c_fvector_pop">c_fvector_pop</h2>
		<pre><code class="language-c">#define c_fvector_pop    fbuffer_pop</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>pop fixed vector last element</description>
		<h2 id="core_containers_c_fvector_insert">c_fvector_insert</h2>
		<pre><code class="language-c">#define c_fvector_insert fbuffer_insert</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>insert element in fixed vector at index</description>
		<h2 id="core_containers_c_fvector_add_at">c_fvector_add_at</h2>
		<pre><code class="language-c">#define c_fvector_add_at fbuffer_add_at</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>add an element in fixed vector at index and return pointer</description>
		<h2 id="core_containers_c_fvector_remove">c_fvector_remove</h2>
		<pre><code class="language-c">#define c_fvector_remove fbuffer_remove</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>remove element in fixed vector at index</description>
		<h2 id="core_containers_c_fvector_clear">c_fvector_clear</h2>
		<pre><code class="language-c">#define c_fvector_clear  fbuffer_free</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>clear all elements in fixed vector</description>
		<h2 id="core_containers_c_fvector_count">c_fvector_count</h2>
		<pre><code class="language-c">#define c_fvector_count  fbuffer_count</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>count elements in fixed vector</description>
		<h2 id="core_containers_c_fvector_add">c_fvector_add</h2>
		<pre><code class="language-c">#define c_fvector_add    fbuffer_add</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>add an element in fixed vector and return pointer</description>
		<h2 id="core_containers_c_fvector_get">c_fvector_get</h2>
		<pre><code class="language-c">#define c_fvector_get    fbuffer_get</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>get element pointer in fixed vector at index</description>
		<h2 id="core_containers_c_fvector_reset">c_fvector_reset</h2>
		<pre><code class="language-c">#define c_fvector_reset  fbuffer_reset</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>reset fixed vector</description>
		<h2 id="core_containers_fstack_struct">fstack_struct</h2>
		<pre><code class="language-c">#define fstack_struct     fbuffer_struct</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>declare a fixed stack struct</description>
		<h2 id="core_containers_fstack_init">fstack_init</h2>
		<pre><code class="language-c">#define fstack_init       fbuffer_init</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>initialize a fixed stack</description>
		<h2 id="core_containers_fstack_var">fstack_var</h2>
		<pre><code class="language-c">#define fstack_var        fbuffer_var</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>declare & initialize a fixed stack on the stack</description>
		<h2 id="core_containers_c_fstack_add">c_fstack_add</h2>
		<pre><code class="language-c">#define c_fstack_add(s)   fbuffer_add(s, 1)</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>add element in fixed stack and return pointer</description>
		<h2 id="core_containers_c_fstack_push">c_fstack_push</h2>
		<pre><code class="language-c">#define c_fstack_push     fbuffer_push</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>push element in fixed stack</description>
		<h2 id="core_containers_c_fstack_pop">c_fstack_pop</h2>
		<pre><code class="language-c">#define c_fstack_pop      fbuffer_pop</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>pop last element in fixed stack</description>
		<h2 id="core_containers_c_fstack_empty">c_fstack_empty</h2>
		<pre><code class="language-c">#define c_fstack_empty(s) (fbuffer_count(s) == 0)</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>check if fixed stack is empty</description>
		<h2 id="core_containers_c_fstack_clear">c_fstack_clear</h2>
		<pre><code class="language-c">#define c_fstack_clear    fbuffer_free</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>clear all elements in fixed stack</description>
		<h2 id="core_containers_c_fstack_reset">c_fstack_reset</h2>
		<pre><code class="language-c">#define c_fstack_reset    fbuffer_reset</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>reset fixed stack</description>
		<h2 id="core_containers_c_fstack_last">c_fstack_last</h2>
		<pre><code class="language-c">#define c_fstack_last(s)  fbuffer_get(s, fbuffer_count(s) - 1)</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>get last element of fixed stack</description>
		<h2 id="core_containers_fqueue_struct">fqueue_struct</h2>
		<pre><code class="language-c">#define fqueue_struct       fbuffer_struct</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>declare a fixed queue struct</description>
		<h2 id="core_containers_fqueue_init">fqueue_init</h2>
		<pre><code class="language-c">#define fqueue_init         fbuffer_init</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>initialize a fixed queue</description>
		<h2 id="core_containers_fqueue_var">fqueue_var</h2>
		<pre><code class="language-c">#define fqueue_var          fbuffer_var</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>declare & initialize a fixed queue on the stack</description>
		<h2 id="core_containers_c_fqueue_enqueue">c_fqueue_enqueue</h2>
		<pre><code class="language-c">#define c_fqueue_enqueue    fbuffer_push</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>enqueue element in fixed queue</description>
		<h2 id="core_containers_c_fqueue_add">c_fqueue_add</h2>
		<pre><code class="language-c">#define c_fqueue_add(q)     fbuffer_add(q, 1)</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>add element in fixed queue and return pointer</description>
		<h2 id="core_containers_c_fqueue_dequeue">c_fqueue_dequeue</h2>
		<pre><code class="language-c">#define c_fqueue_dequeue(q) fbuffer_remove(q, 0)</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>dequeue first element in fixed queue</description>
		<h2 id="core_containers_c_fqueue_empty">c_fqueue_empty</h2>
		<pre><code class="language-c">#define c_fqueue_empty(q)   (fbuffer_count(q) == 0)</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>check if fixed queue is empty</description>
		<h2 id="core_containers_c_fqueue_clear">c_fqueue_clear</h2>
		<pre><code class="language-c">#define c_fqueue_clear      fbuffer_free</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>clear all elements in fixed queue</description>
		<h2 id="core_containers_c_fqueue_reset">c_fqueue_reset</h2>
		<pre><code class="language-c">#define c_fqueue_reset      fbuffer_reset</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>reset fixed queue</description>
		<h2 id="core_containers_map_keys">map_keys</h2>
		<pre><code class="language-c">#define map_keys(m) (m).keys</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>get map keys vector</description>
		<h2 id="core_containers_map_values">map_values</h2>
		<pre><code class="language-c">#define map_values(m) (m).values</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>get map values vector</description>
		<h2 id="core_containers_map_function">map_function</h2>
		<pre><code class="language-c">#define map_function(m) (m).function</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>get map order function</description>
		<h2 id="core_containers_map_internal_key">map_internal_key</h2>
		<pre><code class="language-c">#define map_internal_key(m) (m)._internal_key</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>get map internal key</description>
		<h2 id="core_containers_map_internal_index">map_internal_index</h2>
		<pre><code class="language-c">#define map_internal_index(m) (m)._internal_index</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>get map internal index</description>
		<h2 id="core_containers_map_set_internal_key">map_set_internal_key</h2>
		<pre><code class="language-c">#define map_set_internal_key(m, key) memcpy(&(map_internal_key(m)), &key, sizeof(map_internal_key(m)))</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>set map internal key</description>
		<h2 id="core_containers_map_set_internal_pod_key">map_set_internal_pod_key</h2>
		<pre><code class="language-c">#define map_set_internal_pod_key(m, key) map_internal_key(m) = key</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>set map internal key as pod</description>
		<h2 id="core_containers_map_set_internal_index">map_set_internal_index</h2>
		<pre><code class="language-c">#define map_set_internal_index(m, index) map_internal_index(m) = index</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>set map internal index</description>
		<h2 id="core_containers_map_current_value_pointer">map_current_value_pointer</h2>
		<pre><code class="language-c">#define map_current_value_pointer(m) &(map_values(m)[map_internal_index(m)])</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>get value pointer of element at current index</description>
		<h2 id="core_containers_map_struct">map_struct</h2>
		<pre><code class="language-c">#define map_struct(name, key, value) struct { key *keys; value *values; order_func function; uint _internal_index; key _internal_key; } name</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>declare map struct</description>
		<h2 id="core_containers_map_init">map_init</h2>
		<pre><code class="language-c">#define map_init(order) { NULL, NULL, order, C_INVALID_INDEX }</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>initialize map struct</description>
		<h2 id="core_containers_map_var">map_var</h2>
		<pre><code class="language-c">#define map_var(name, key, value, order) map_struct(name, key, value) = map_init(order)</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>declare and initialize map on the stack</description>
		<h2 id="core_containers_c_map_count">c_map_count</h2>
		<pre><code class="language-c">#define c_map_count(m) (c_vector_count(map_keys(m)))</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>count map elements</description>
		<h2 id="core_containers_c_map_clear">c_map_clear</h2>
		<pre><code class="language-c">#define c_map_clear(m) (c_vector_clear(map_keys(m)), c_vector_clear(map_values(m)))</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>clear all map elements</description>
		<h2 id="core_containers_c_map_find">c_map_find</h2>
		<pre><code class="language-c">#define c_map_find(m, key) (map_set_internal_key(m, key), c_array_sorted_find(map_keys(m), sizeof(map_internal_key(m)), c_map_count(m), &(map_internal_key(m)), map_function(m)))</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>find index of map element</description>
		<h2 id="core_containers_c_map_remove">c_map_remove</h2>
		<pre><code class="language-c">#define c_map_remove(m, key) (map_set_internal_index(m, c_map_find(m, key)), c_vector_remove(map_keys(m), map_internal_index(m)), c_vector_remove(map_values(m), map_internal_index(m)))</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>remove map element</description>
		<h2 id="core_containers_c_map_remove_at">c_map_remove_at</h2>
		<pre><code class="language-c">#define c_map_remove_at(m, index) (c_vector_remove(map_keys(m), index), c_vector_remove(map_values(m), index))</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>remove map element at index</description>
		<h2 id="core_containers_c_map_set">c_map_set</h2>
		<pre><code class="language-c">#define c_map_set(m, key, value)\
(map_set_internal_key(m, key),\
  c_array_sorted_insert_index(map_keys(m), sizeof(map_internal_key(m)), c_map_count(m), &(map_internal_key(m)), map_function(m), &(map_internal_index(m))) ?\
  (c_vector_insert(map_keys(m), map_internal_index(m), map_internal_key(m)), c_vector_insert(map_values(m), map_internal_index(m), value)) :\
    (memcpy(&(map_values(m)[map_internal_index(m)]), &value, sizeof(value))\
)</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description>
			<b>description: </b>map set<br>
			set internal key<br>
			check result of insert index test (setting internal index)<br>
			if false (key already exists), set value<br>
			if true insert internal key to internal index, insert value to internal index
		</description>
		<h2 id="core_containers_c_map_get">c_map_get</h2>
		<pre><code class="language-c">#define c_map_get(m, key)\
(map_set_internal_key(m, key),\
  c_array_sorted_insert_index(map_keys(m), sizeof(map_internal_key(m)), c_map_count(m), &(map_internal_key(m)), map_function(m), &(map_internal_index(m))) ?\
  (c_vector_insert(map_keys(m), map_internal_key(m), map_internal_index(m)), c_vector_add_at(map_values(m), map_internal_index(m)) : 0\
    , (map_current_value_pointer(m))\
)</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description>
			<b>description: </b>map get<br>
			set internal key<br>
			check result of insert index test (setting internal index)<br>
			if false (key already exists), return value pointer (from internal index)<br>
			if true insert internal key to internal index, return value pointer (from internal index)
		</description>
	</section>
	<nav class="menu">
		<a href="../index.html">Home</a>
		<a href="cmake.html">cmake</a>
		<a href="ftest.html">ftest</a>
		<a href="math.html">math</a>
		<a href="core.html">core</a>
		<a class="section" href="core_defines.html">defines</a>
		<a class="section" href="core_main_functions.html">main functions</a>
		<a class="section" href="core_time.html">time</a>
		<a class="section" href="core_rng.html">rng</a>
		<a class="section" href="core_bit_operation.html">bit operation</a>
		<a class="section" href="core_algorithms.html">algorithms</a>
		<a class="section" href="core_memory.html">memory</a>
		<a class="section" href="core_strings.html">strings</a>
		<a class="section" href="core_path.html">path</a>
		<a class="section" href="core_byte_array.html">byte array</a>
		<a class="section" href="core_filesystem.html">filesystem</a>
		<a class="section" href="core_datetime.html">datetime</a>
		<a class="section" href="core_output.html">output</a>
		<a class="section" href="core_log.html">log</a>
		<a class="current_section" href="core_containers.html">containers</a>
		<a class="section" href="core_compression.html">compression</a>
		<a class="section" href="core_commands.html">commands</a>
		<a class="section" href="core_multi-threading.html">multi-threading</a>
		<a class="section" href="core_streams.html">streams</a>
		<a href="image.html">image</a>
		<a href="graphics.html">graphics</a>
		<a href="util.html">util</a>
		<a href="documentation.html">documentation</a>
		<a href="learn_opengl_-_getting_started.html">learn_opengl - getting started</a>
	</nav>
	<footer>
		<p>Another Memory Ends - Reference</p>
	</footer>
</body>
</html>
