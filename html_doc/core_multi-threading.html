<!DOCTYPE html>
<!-- Generated by ame util library - using PrismJS 1.20.0 -->
<html>
<head>
	<meta charset="UTF-8">
	<title>Another Memory Ends</title>
	<link rel="stylesheet" type="text/css" href="../CSS/docgen_style.css">
	<link rel="stylesheet" type="text/css" href="../CSS/prism.css">
</head>
<body>
	<script src="../JS/prism.js">
	</script>
	<h1>multi-threading</h1>
	<br>
	<p>functions and data types to run code asynchronously and concurrently</p>
	<br>
	<section class="main">
		<h2 id="core_multi-threading_mt_uint">mt_uint</h2>
		<pre><code class="language-c">typedef struct {
  Lock lock;
  uint value;
} mt_uint;
</code></pre>
		<description><b>type:</b> <i>C struct</i></description>
		<br>
		<description><b>description: </b>uint variable for multi-threading</description>
		<h2 id="core_multi-threading_c_mt_uint_initialize">c_mt_uint_initialize</h2>
		<pre><code class="language-c">void c_mt_uint_initialize(mt_uint *p, uint value);</code></pre>
		<description><b>type:</b> <i>C function</i></description>
		<br>
		<description><b>description: </b>initialize a mt_uint</description>
		<h2 id="core_multi-threading_c_mt_uint_get">c_mt_uint_get</h2>
		<pre><code class="language-c">uint c_mt_uint_get(mt_uint *p);</code></pre>
		<description><b>type:</b> <i>C function</i></description>
		<br>
		<description><b>description: </b>get value of mt_uint</description>
		<h2 id="core_multi-threading_c_mt_uint_set">c_mt_uint_set</h2>
		<pre><code class="language-c">void c_mt_uint_set(mt_uint *p, uint value);</code></pre>
		<description><b>type:</b> <i>C function</i></description>
		<br>
		<description><b>description: </b>set mt_uint value</description>
		<h2 id="core_multi-threading_c_mt_uint_terminate">c_mt_uint_terminate</h2>
		<pre><code class="language-c">void c_mt_uint_terminate(mt_uint *p);</code></pre>
		<description><b>type:</b> <i>C function</i></description>
		<br>
		<description><b>description: </b>terminate mt_uint</description>
		<h2 id="core_multi-threading_C_JOB_DONE">C_JOB_DONE</h2>
		<pre><code class="language-c">#define C_JOB_DONE     0</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>return if job should release</description>
		<h2 id="core_multi-threading_C_JOB_CONTINUE">C_JOB_CONTINUE</h2>
		<pre><code class="language-c">#define C_JOB_CONTINUE 1</code></pre>
		<description><b>type:</b> <i>C preprocessor definition</i></description>
		<br>
		<description><b>description: </b>return if job should continue</description>
		<h2 id="core_multi-threading_job_func">job_func</h2>
		<pre><code class="language-c">typedef uint(*job_func)(void*);</code></pre>
		<description><b>type:</b> <i>C typedef</i></description>
		<br>
		<description>
			<b>description: </b>job function pointer<br>
			return C_JOB_DONE if job is finished <br>
			return C_JOB_CONTINUE if job needs to run again
		</description>
		<h2 id="core_multi-threading_Job">Job</h2>
		<pre><code class="language-c">typedef struct {
  job_func function;
  uint8    data[512];
} Job;
</code></pre>
		<description><b>type:</b> <i>C struct</i></description>
		<br>
		<description><b>description: </b>job - function & data bytes</description>
		<h2 id="core_multi-threading_c_job_set">c_job_set</h2>
		<pre><code class="language-c">void c_job_set(Job *job, job_func function, void *data, size_t size);</code></pre>
		<description><b>type:</b> <i>C function</i></description>
		<h2 id="core_multi-threading_AsyncJobState">AsyncJobState</h2>
		<description><b>type:</b> <i>C enum</i></description>
		<br>
		<description><b>description: </b>async job status</description>
		<table>
			<tbody>
				<tr>
				<td><code>  ASYNC_JOB_IDLE</code></td>
				<td>job was created</td>
				</tr>
				<tr>
				<td><code>  ASYNC_JOB_QUEUED</code></td>
				<td>job was queued</td>
				</tr>
				<tr>
				<td><code>  ASYNC_JOB_PROCESSING</code></td>
				<td>job has started</td>
				</tr>
				<tr>
				<td><code>  ASYNC_JOB_FINISHED</code></td>
				<td>job has finished</td>
				</tr>
				<tr>
				<td><code>  ASYNC_JOB_STATE_COUNT</code></td>
				<td></td>
				</tr>
			</tbody>
		</table>
		<h2 id="core_multi-threading_AsyncJob">AsyncJob</h2>
		<pre><code class="language-c">typedef struct {
  mt_uint state;
  Job     job;
} AsyncJob;
</code></pre>
		<description><b>type:</b> <i>C struct</i></description>
		<br>
		<description><b>description: </b>Asynchronous job - job and state</description>
		<h2 id="core_multi-threading_c_parallel_async_job_initialize">c_parallel_async_job_initialize</h2>
		<pre><code class="language-c">void c_parallel_async_job_initialize(AsyncJob *async);</code></pre>
		<description><b>type:</b> <i>C function</i></description>
		<br>
		<description><b>description: </b>initialize asynchronous job</description>
		<h2 id="core_multi-threading_c_parallel_async_job_terminate">c_parallel_async_job_terminate</h2>
		<pre><code class="language-c">void c_parallel_async_job_terminate(AsyncJob *async);</code></pre>
		<description><b>type:</b> <i>C function</i></description>
		<br>
		<description><b>description: </b>terminate asynchronous job</description>
		<h2 id="core_multi-threading_c_parallel_start">c_parallel_start</h2>
		<pre><code class="language-c">void c_parallel_start(uint thread_count);</code></pre>
		<description><b>type:</b> <i>C function</i></description>
		<br>
		<description><b>description: </b>starts thread pool, 0 to use all cores</description>
		<h2 id="core_multi-threading_c_parallel_stop">c_parallel_stop</h2>
		<pre><code class="language-c">void c_parallel_stop();</code></pre>
		<description><b>type:</b> <i>C function</i></description>
		<br>
		<description><b>description: </b>stops thread pool</description>
		<h2 id="core_multi-threading_c_parallel_queue">c_parallel_queue</h2>
		<pre><code class="language-c">void c_parallel_queue(AsyncJob *async_job);</code></pre>
		<description><b>type:</b> <i>C function</i></description>
		<br>
		<description><b>description: </b>queue asynchronous job</description>
		<h2 id="core_multi-threading_c_parallel_execute">c_parallel_execute</h2>
		<pre><code class="language-c">void c_parallel_execute(Job *jobs, uint count);</code></pre>
		<description><b>type:</b> <i>C function</i></description>
		<br>
		<description><b>description: </b>execute jobs concurrently by requesting all threads</description>
	</section>
	<nav class="menu">
		<a href="../index.html">Home</a>
		<a href="cmake.html">cmake</a>
		<a href="ftest.html">ftest</a>
		<a href="math.html">math</a>
		<a href="core.html">core</a>
		<a class="section" href="core_defines.html">defines</a>
		<a class="section" href="core_main_functions.html">main functions</a>
		<a class="section" href="core_time.html">time</a>
		<a class="section" href="core_rng.html">rng</a>
		<a class="section" href="core_bit_operation.html">bit operation</a>
		<a class="section" href="core_algorithms.html">algorithms</a>
		<a class="section" href="core_memory.html">memory</a>
		<a class="section" href="core_strings.html">strings</a>
		<a class="section" href="core_path.html">path</a>
		<a class="section" href="core_byte_array.html">byte array</a>
		<a class="section" href="core_filesystem.html">filesystem</a>
		<a class="section" href="core_datetime.html">datetime</a>
		<a class="section" href="core_output.html">output</a>
		<a class="section" href="core_log.html">log</a>
		<a class="section" href="core_dynamic_buffer.html">dynamic buffer</a>
		<a class="section" href="core_compression.html">compression</a>
		<a class="section" href="core_commands.html">commands</a>
		<a class="current_section" href="core_multi-threading.html">multi-threading</a>
		<a class="section" href="core_streams.html">streams</a>
		<a href="image.html">image</a>
		<a href="graphics.html">graphics</a>
		<a href="util.html">util</a>
		<a href="framework.html">framework</a>
		<a href="documentation.html">documentation</a>
		<a href="learn_opengl_-_getting_started.html">learn_opengl - getting started</a>
		<a href="learn_opengl_-_lighting.html">learn_opengl - lighting</a>
	</nav>
	<footer>
		<p>Another Memory Ends - Reference</p>
	</footer>
</body>
</html>
