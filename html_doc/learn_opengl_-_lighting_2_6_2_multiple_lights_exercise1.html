<!DOCTYPE html>
<!-- Generated by ame util library - using PrismJS 1.20.0 -->
<html>
<head>
	<meta charset="UTF-8">
	<title>Another Memory Ends</title>
	<link rel="stylesheet" type="text/css" href="../CSS/docgen_style.css">
	<link rel="stylesheet" type="text/css" href="../CSS/prism.css">
</head>
<body>
	<script src="../JS/prism.js">
	</script>
	<h1>2_6_2_multiple_lights_exercise1</h1>
	<br>
	<p></p>
	<br>
	<section class="main">
		<h2 id="learn_opengl_-_lighting_2_6_2_multiple_lights_exercise1_result">result</h2>
		<img src="../res/2_6_2_multiple_lights_exercise1.gif" alt="result">
		<h2 id="learn_opengl_-_lighting_2_6_2_multiple_lights_exercise1_source">source</h2>
		<pre><code class="language-c">/*
 * 2_6_2_multiple_lights_exercise1.c
 * Another Memory Ends - amedevcentral@gmail.com
 * Copyright
 * based on LearnOpenGL https://learnopengl.com/Lighting/Multiple-lights
 * by Joey de Vries https://twitter.com/JoeyDeVriez
 * license https://creativecommons.org/licenses/by-nc/4.0/legalcode
 */
#include "framework.h"

const size_t gc_core_memory_size = 0;

void resize_callback(AmeWindow* window, uint width, uint height);
void input_callback(AmeWindow* window, const InputEvent* event);

FreeflyCamera camera;

float delta_time = 0.0f;
float last_frame = 0.0f;

enum {
	LOOK_DESERT,
	LOOK_FACTORY,
	LOOK_HORROR,
	LOOK_BIOCHEMICAL_LAB
};

int current_look = LOOK_DESERT;

int main(int argc, char** argv)
{
	(void)argc;
	(void)argv;
	f_initialize(C_OUTPUT_FULL, 0);

	AmeWindow *window = f_window_create("graphics_2_lighting_6_2_multiple_lights_exercise1", 800, 600, WINDOW_STYLE_DEFAULT);
	f_window_set_input_callback(window, input_callback);
	f_window_set_resize_callback(window, resize_callback);
	f_window_cursor_mode(window, CURSOR_DISABLE);
	f_window_set_current(window);

	ColorVec4 clear_color = { 0.0f, 0.0f, 0.0f, 0.0f };
	gfx_clear_color_set(clear_color);

	gfx_id lighting_shader = gfx_shader_create_from_files(
		"./2_6_2_multiple_lights_exercise1_vs.glsl",
		"./2_6_2_multiple_lights_exercise1_fs.glsl", &gc_gfx_shader_link_default);
	gfx_id light_cube_shader = gfx_shader_create_from_files("./2_6_2_light_cube_vs.glsl", "./2_6_2_light_cube_fs.glsl", &gc_gfx_shader_link_default);

	float vertices[] = {
		// positions          // normals           // texture coords
		-0.5f, -0.5f, -0.5f,  0.0f,  0.0f, -1.0f,  0.0f, 0.0f,
		0.5f, -0.5f, -0.5f,  0.0f,  0.0f, -1.0f,  1.0f, 0.0f,
		0.5f,  0.5f, -0.5f,  0.0f,  0.0f, -1.0f,  1.0f, 1.0f,
		0.5f,  0.5f, -0.5f,  0.0f,  0.0f, -1.0f,  1.0f, 1.0f,
		-0.5f,  0.5f, -0.5f,  0.0f,  0.0f, -1.0f,  0.0f, 1.0f,
		-0.5f, -0.5f, -0.5f,  0.0f,  0.0f, -1.0f,  0.0f, 0.0f,

		-0.5f, -0.5f,  0.5f,  0.0f,  0.0f, 1.0f,   0.0f, 0.0f,
		0.5f, -0.5f,  0.5f,  0.0f,  0.0f, 1.0f,   1.0f, 0.0f,
		0.5f,  0.5f,  0.5f,  0.0f,  0.0f, 1.0f,   1.0f, 1.0f,
		0.5f,  0.5f,  0.5f,  0.0f,  0.0f, 1.0f,   1.0f, 1.0f,
		-0.5f,  0.5f,  0.5f,  0.0f,  0.0f, 1.0f,   0.0f, 1.0f,
		-0.5f, -0.5f,  0.5f,  0.0f,  0.0f, 1.0f,   0.0f, 0.0f,

		-0.5f,  0.5f,  0.5f, -1.0f,  0.0f,  0.0f,  1.0f, 0.0f,
		-0.5f,  0.5f, -0.5f, -1.0f,  0.0f,  0.0f,  1.0f, 1.0f,
		-0.5f, -0.5f, -0.5f, -1.0f,  0.0f,  0.0f,  0.0f, 1.0f,
		-0.5f, -0.5f, -0.5f, -1.0f,  0.0f,  0.0f,  0.0f, 1.0f,
		-0.5f, -0.5f,  0.5f, -1.0f,  0.0f,  0.0f,  0.0f, 0.0f,
		-0.5f,  0.5f,  0.5f, -1.0f,  0.0f,  0.0f,  1.0f, 0.0f,

		0.5f,  0.5f,  0.5f,  1.0f,  0.0f,  0.0f,  1.0f, 0.0f,
		0.5f,  0.5f, -0.5f,  1.0f,  0.0f,  0.0f,  1.0f, 1.0f,
		0.5f, -0.5f, -0.5f,  1.0f,  0.0f,  0.0f,  0.0f, 1.0f,
		0.5f, -0.5f, -0.5f,  1.0f,  0.0f,  0.0f,  0.0f, 1.0f,
		0.5f, -0.5f,  0.5f,  1.0f,  0.0f,  0.0f,  0.0f, 0.0f,
		0.5f,  0.5f,  0.5f,  1.0f,  0.0f,  0.0f,  1.0f, 0.0f,

		-0.5f, -0.5f, -0.5f,  0.0f, -1.0f,  0.0f,  0.0f, 1.0f,
		0.5f, -0.5f, -0.5f,  0.0f, -1.0f,  0.0f,  1.0f, 1.0f,
		0.5f, -0.5f,  0.5f,  0.0f, -1.0f,  0.0f,  1.0f, 0.0f,
		0.5f, -0.5f,  0.5f,  0.0f, -1.0f,  0.0f,  1.0f, 0.0f,
		-0.5f, -0.5f,  0.5f,  0.0f, -1.0f,  0.0f,  0.0f, 0.0f,
		-0.5f, -0.5f, -0.5f,  0.0f, -1.0f,  0.0f,  0.0f, 1.0f,

		-0.5f,  0.5f, -0.5f,  0.0f,  1.0f,  0.0f,  0.0f, 1.0f,
		0.5f,  0.5f, -0.5f,  0.0f,  1.0f,  0.0f,  1.0f, 1.0f,
		0.5f,  0.5f,  0.5f,  0.0f,  1.0f,  0.0f,  1.0f, 0.0f,
		0.5f,  0.5f,  0.5f,  0.0f,  1.0f,  0.0f,  1.0f, 0.0f,
		-0.5f,  0.5f,  0.5f,  0.0f,  1.0f,  0.0f,  0.0f, 0.0f,
		-0.5f,  0.5f, -0.5f,  0.0f,  1.0f,  0.0f,  0.0f, 1.0f
	};

	GfxAttributeFormat format = C_GFX_FORMAT_NULL;
	gfx_attribute_add(&format, "pos", GFX_ATTRIBUTE_VEC3);
	gfx_attribute_add(&format, "normal", GFX_ATTRIBUTE_VEC3);
	gfx_attribute_add(&format, "uv", GFX_ATTRIBUTE_VEC2);

	gfx_id vertex_buffer = gfx_vertex_buffer_create();
	gfx_id cube_va = gfx_vertex_array_create();
	gfx_id light_cube_va = gfx_vertex_array_create();

	gfx_vertex_array_bind(cube_va);
	gfx_vertex_buffer_bind(vertex_buffer);
	gfx_vertex_buffer_copy_data((const uint8*)vertices, sizeof(vertices), GFX_BUFFER_STATIC);

	gfx_attributes_enable_interleaved(&format);
	gfx_vertex_array_bind(0);

	gfx_vertex_array_bind(light_cube_va);
	gfx_vertex_buffer_bind(vertex_buffer);
	gfx_attribute_enable(&format, "normal", false); // disable normal
	gfx_attribute_enable(&format, "uv", false); // disable normal
	gfx_attributes_enable_interleaved(&format);
	gfx_vertex_array_bind(0);

	vec3 cube_positions[] = {
		{ 0.0f,  0.0f,  0.0f },
		{ 2.0f,  5.0f, -15.0f },
		{ -1.5f, -2.2f, -2.5f },
		{ -3.8f, -2.0f, -12.3f },
		{ 2.4f, -0.4f, -3.5f },
		{ -1.7f,  3.0f, -7.5f },
		{ 1.3f, -2.0f, -2.5f },
		{ 1.5f,  2.0f, -2.5f },
		{ 1.5f,  0.2f, -1.5f },
		{ -1.3f,  1.0f, -1.5f }
	};

	vec3 point_lights_positions[] = {
		{ 0.7f,  0.2f,  2.0f },
		{ 2.3f, -3.3f, -4.0f },
		{ -4.0f,  2.0f, -12.0f },
		{ 0.0f,  0.0f, -3.0f }
	};

	mat4 model;
	mat4 projection;

	gfx_depth_testing(true);

	f_input_cursor_center_screen();

	vec3 pos = { -1.7f, -0.8f, 2.9f };
	f_camera_freefly_reset(&camera, pos);
	vec3 at = { 2.0f, 1.5f, -1.0f };
	f_camera_freefly_look_at(&camera, at);

	Image *diffuse_image = i_image_alloc_from_file("./gfx_test_resources/container2.png");
	gfx_id diffuse_map = gfx_texture_import(diffuse_image, &gc_gfx_texture_parameters_default);
	i_image_free(diffuse_image);

	Image *specular_image = i_image_alloc_from_file("./gfx_test_resources/container2_specular.png");
	gfx_id specular_map = gfx_texture_import(specular_image, &gc_gfx_texture_parameters_default);
	i_image_free(specular_image);

	gfx_shader_use(lighting_shader);
	gfx_shader_int_set(lighting_shader, "material.diffuse", 0);
	gfx_shader_int_set(lighting_shader, "material.specular", 1);

	float timer = 0.0f;

	while (f_window_should_close(window) == false)
	{
		float current_frame = (float)c_time_seconds();
		delta_time = current_frame - last_frame;
		last_frame = current_frame;

		timer += delta_time;
		if (timer > 1.5f)
		{
			timer = 0.0f;
			current_look++;
			if (current_look > LOOK_BIOCHEMICAL_LAB) current_look = 0;
		}

		f_window_process_messages(window);
		gfx_framebuffer_bind(0);
		gfx_clear(true, true, false);

		gfx_shader_use(lighting_shader);
		gfx_shader_float_set(lighting_shader, "material.shininess", 32.0f);

		m_mat4_perspective_fov_rh(m_radians(camera.zoom), f_window_aspect(window), 0.1f, 100.0f, projection);
		gfx_shader_mat4_set(lighting_shader, "projection", projection);
		gfx_shader_mat4_set(lighting_shader, "view", camera.view);
		gfx_shader_vec3_set(lighting_shader, "view_pos", camera.position);

		vec3 point_light_colors[4];

		switch (current_look)
		{
		case LOOK_DESERT:
		{
			array_set_4(clear_color, 0.75f, 0.52f, 0.4f, 1.0f);
			gfx_clear_color_set(clear_color);

			array_set_3(point_light_colors[0], 1.0f, 0.6f, 0.0f);
			array_set_3(point_light_colors[1], 1.0f, 0.0f, 0.0f);
			array_set_3(point_light_colors[2], 1.0f, 1.0f, 0.0f);
			array_set_3(point_light_colors[3], 0.2f, 0.2f, 1.0f);

			// Directional light
			gfx_shader_vec3_set_values(lighting_shader, "dir_light.direction", -0.2f, -1.0f, -0.3f);
			gfx_shader_vec3_set_values(lighting_shader, "dir_light.ambient", 0.3f, 0.24f, 0.14f);
			gfx_shader_vec3_set_values(lighting_shader, "dir_light.diffuse", 0.7f, 0.42f, 0.26f);
			gfx_shader_vec3_set_values(lighting_shader, "dir_light.specular", 0.5f, 0.5f, 0.5f);
			// Point light 1
			gfx_shader_vec3_set_values(lighting_shader, "point_lights[0].position", point_lights_positions[0][0], point_lights_positions[0][1], point_lights_positions[0][2]);
			gfx_shader_vec3_set_values(lighting_shader, "point_lights[0].ambient", point_light_colors[0][0] * 0.1f, point_light_colors[0][1] * 0.1f, point_light_colors[0][2] * 0.1f);
			gfx_shader_vec3_set_values(lighting_shader, "point_lights[0].diffuse", point_light_colors[0][0], point_light_colors[0][1], point_light_colors[0][2]);
			gfx_shader_vec3_set_values(lighting_shader, "point_lights[0].specular", point_light_colors[0][0], point_light_colors[0][1], point_light_colors[0][2]);
			gfx_shader_float_set(lighting_shader, "point_lights[0].constant", 1.0f);
			gfx_shader_float_set(lighting_shader, "point_lights[0].linear", 0.09f);
			gfx_shader_float_set(lighting_shader, "point_lights[0].quadratic", 0.032f);
			// Point light 2
			gfx_shader_vec3_set_values(lighting_shader, "point_lights[1].position", point_lights_positions[1][0], point_lights_positions[1][1], point_lights_positions[1][2]);
			gfx_shader_vec3_set_values(lighting_shader, "point_lights[1].ambient", point_light_colors[1][0] * 0.1f, point_light_colors[1][1] * 0.1f, point_light_colors[1][2] * 0.1f);
			gfx_shader_vec3_set_values(lighting_shader, "point_lights[1].diffuse", point_light_colors[1][0], point_light_colors[1][1], point_light_colors[1][2]);
			gfx_shader_vec3_set_values(lighting_shader, "point_lights[1].specular", point_light_colors[1][0], point_light_colors[1][1], point_light_colors[1][2]);
			gfx_shader_float_set(lighting_shader, "point_lights[1].constant", 1.0f);
			gfx_shader_float_set(lighting_shader, "point_lights[1].linear", 0.09f);
			gfx_shader_float_set(lighting_shader, "point_lights[1].quadratic", 0.032f);
			// Point light 3
			gfx_shader_vec3_set_values(lighting_shader, "point_lights[2].position", point_lights_positions[2][0], point_lights_positions[2][1], point_lights_positions[2][2]);
			gfx_shader_vec3_set_values(lighting_shader, "point_lights[2].ambient", point_light_colors[2][0] * 0.1f, point_light_colors[2][1] * 0.1f, point_light_colors[2][2] * 0.1f);
			gfx_shader_vec3_set_values(lighting_shader, "point_lights[2].diffuse", point_light_colors[2][0], point_light_colors[2][1], point_light_colors[2][2]);
			gfx_shader_vec3_set_values(lighting_shader, "point_lights[2].specular", point_light_colors[2][0], point_light_colors[2][1], point_light_colors[2][2]);
			gfx_shader_float_set(lighting_shader, "point_lights[2].constant", 1.0f);
			gfx_shader_float_set(lighting_shader, "point_lights[2].linear", 0.09f);
			gfx_shader_float_set(lighting_shader, "point_lights[2].quadratic", 0.032f);
			// Point light 4
			gfx_shader_vec3_set_values(lighting_shader, "point_lights[3].position", point_lights_positions[3][0], point_lights_positions[3][1], point_lights_positions[3][2]);
			gfx_shader_vec3_set_values(lighting_shader, "point_lights[3].ambient", point_light_colors[3][0] * 0.1f, point_light_colors[3][1] * 0.1f, point_light_colors[3][2] * 0.1f);
			gfx_shader_vec3_set_values(lighting_shader, "point_lights[3].diffuse", point_light_colors[3][0], point_light_colors[3][1], point_light_colors[3][2]);
			gfx_shader_vec3_set_values(lighting_shader, "point_lights[3].specular", point_light_colors[3][0], point_light_colors[3][1], point_light_colors[3][2]);
			gfx_shader_float_set(lighting_shader, "point_lights[3].constant", 1.0f);
			gfx_shader_float_set(lighting_shader, "point_lights[3].linear", 0.09f);
			gfx_shader_float_set(lighting_shader, "point_lights[3].quadratic", 0.032f);
			// SpotLight
			gfx_shader_vec3_set_values(lighting_shader, "spot_light.position", camera.position[0], camera.position[1], camera.position[2]);
			gfx_shader_vec3_set_values(lighting_shader, "spot_light.direction", camera.front[0], camera.front[1], camera.front[2]);
			gfx_shader_vec3_set_values(lighting_shader, "spot_light.ambient", 0.0f, 0.0f, 0.0f);
			gfx_shader_vec3_set_values(lighting_shader, "spot_light.diffuse", 0.8f, 0.8f, 0.0f);
			gfx_shader_vec3_set_values(lighting_shader, "spot_light.specular", 0.8f, 0.8f, 0.0f);
			gfx_shader_float_set(lighting_shader, "spot_light.constant", 1.0f);
			gfx_shader_float_set(lighting_shader, "spot_light.linear", 0.09f);
			gfx_shader_float_set(lighting_shader, "spot_light.quadratic", 0.032f);
			gfx_shader_float_set(lighting_shader, "spot_light.cut_off", cosf(m_radians(12.5f)));
			gfx_shader_float_set(lighting_shader, "spot_light.outer_cut_off", cosf(m_radians(13.0f)));
		}
		break;
		case LOOK_FACTORY:
		{
			array_set_4(clear_color, 0.1f, 0.1f, 0.1f, 1.0f);
			gfx_clear_color_set(clear_color);

			array_set_3(point_light_colors[0], 0.2f, 0.2f, 0.6f);
			array_set_3(point_light_colors[1], 0.3f, 0.3f, 0.7f);
			array_set_3(point_light_colors[2], 0.0f, 0.0f, 0.3f);
			array_set_3(point_light_colors[3], 0.4f, 0.4f, 0.4f);

			// Directional light
			gfx_shader_vec3_set_values(lighting_shader, "dir_light.direction", -0.2f, -1.0f, -0.3f);
			gfx_shader_vec3_set_values(lighting_shader, "dir_light.ambient", 0.05f, 0.05f, 0.1f);
			gfx_shader_vec3_set_values(lighting_shader, "dir_light.diffuse", 0.2f, 0.2f, 0.7f);
			gfx_shader_vec3_set_values(lighting_shader, "dir_light.specular", 0.7f, 0.7f, 0.7f);
			// Point light 1
			gfx_shader_vec3_set_values(lighting_shader, "point_lights[0].position", point_lights_positions[0][0], point_lights_positions[0][1], point_lights_positions[0][2]);
			gfx_shader_vec3_set_values(lighting_shader, "point_lights[0].ambient", point_light_colors[0][0] * 0.1f, point_light_colors[0][1] * 0.1f, point_light_colors[0][2] * 0.1f);
			gfx_shader_vec3_set_values(lighting_shader, "point_lights[0].diffuse", point_light_colors[0][0], point_light_colors[0][1], point_light_colors[0][2]);
			gfx_shader_vec3_set_values(lighting_shader, "point_lights[0].specular", point_light_colors[0][0], point_light_colors[0][1], point_light_colors[0][2]);
			gfx_shader_float_set(lighting_shader, "point_lights[0].constant", 1.0f);
			gfx_shader_float_set(lighting_shader, "point_lights[0].linear", 0.09f);
			gfx_shader_float_set(lighting_shader, "point_lights[0].quadratic", 0.032f);
			// Point light 2
			gfx_shader_vec3_set_values(lighting_shader, "point_lights[1].position", point_lights_positions[1][0], point_lights_positions[1][1], point_lights_positions[1][2]);
			gfx_shader_vec3_set_values(lighting_shader, "point_lights[1].ambient", point_light_colors[1][0] * 0.1f, point_light_colors[1][1] * 0.1f, point_light_colors[1][2] * 0.1f);
			gfx_shader_vec3_set_values(lighting_shader, "point_lights[1].diffuse", point_light_colors[1][0], point_light_colors[1][1], point_light_colors[1][2]);
			gfx_shader_vec3_set_values(lighting_shader, "point_lights[1].specular", point_light_colors[1][0], point_light_colors[1][1], point_light_colors[1][2]);
			gfx_shader_float_set(lighting_shader, "point_lights[1].constant", 1.0f);
			gfx_shader_float_set(lighting_shader, "point_lights[1].linear", 0.09f);
			gfx_shader_float_set(lighting_shader, "point_lights[1].quadratic", 0.032f);
			// Point light 3
			gfx_shader_vec3_set_values(lighting_shader, "point_lights[2].position", point_lights_positions[2][0], point_lights_positions[2][1], point_lights_positions[2][2]);
			gfx_shader_vec3_set_values(lighting_shader, "point_lights[2].ambient", point_light_colors[2][0] * 0.1f, point_light_colors[2][1] * 0.1f, point_light_colors[2][2] * 0.1f);
			gfx_shader_vec3_set_values(lighting_shader, "point_lights[2].diffuse", point_light_colors[2][0], point_light_colors[2][1], point_light_colors[2][2]);
			gfx_shader_vec3_set_values(lighting_shader, "point_lights[2].specular", point_light_colors[2][0], point_light_colors[2][1], point_light_colors[2][2]);
			gfx_shader_float_set(lighting_shader, "point_lights[2].constant", 1.0f);
			gfx_shader_float_set(lighting_shader, "point_lights[2].linear", 0.09f);
			gfx_shader_float_set(lighting_shader, "point_lights[2].quadratic", 0.032f);
			// Point light 4
			gfx_shader_vec3_set_values(lighting_shader, "point_lights[3].position", point_lights_positions[3][0], point_lights_positions[3][1], point_lights_positions[3][2]);
			gfx_shader_vec3_set_values(lighting_shader, "point_lights[3].ambient", point_light_colors[3][0] * 0.1f, point_light_colors[3][1] * 0.1f, point_light_colors[3][2] * 0.1f);
			gfx_shader_vec3_set_values(lighting_shader, "point_lights[3].diffuse", point_light_colors[3][0], point_light_colors[3][1], point_light_colors[3][2]);
			gfx_shader_vec3_set_values(lighting_shader, "point_lights[3].specular", point_light_colors[3][0], point_light_colors[3][1], point_light_colors[3][2]);
			gfx_shader_float_set(lighting_shader, "point_lights[3].constant", 1.0f);
			gfx_shader_float_set(lighting_shader, "point_lights[3].linear", 0.09f);
			gfx_shader_float_set(lighting_shader, "point_lights[3].quadratic", 0.032f);
			// SpotLight
			gfx_shader_vec3_set_values(lighting_shader, "spot_light.position", camera.position[0], camera.position[1], camera.position[2]);
			gfx_shader_vec3_set_values(lighting_shader, "spot_light.direction", camera.front[0], camera.front[1], camera.front[2]);
			gfx_shader_vec3_set_values(lighting_shader, "spot_light.ambient", 0.0f, 0.0f, 0.0f);
			gfx_shader_vec3_set_values(lighting_shader, "spot_light.diffuse", 1.0f, 1.0f, 1.0f);
			gfx_shader_vec3_set_values(lighting_shader, "spot_light.specular", 1.0f, 1.0f, 1.0f);
			gfx_shader_float_set(lighting_shader, "spot_light.constant", 1.0f);
			gfx_shader_float_set(lighting_shader, "spot_light.linear", 0.009f);
			gfx_shader_float_set(lighting_shader, "spot_light.quadratic", 0.0032f);
			gfx_shader_float_set(lighting_shader, "spot_light.cut_off", cosf(m_radians(10.0f)));
			gfx_shader_float_set(lighting_shader, "spot_light.outer_cut_off", cosf(m_radians(12.5f)));
		}
		break;
		case LOOK_HORROR:
		{
			array_set_4(clear_color, 0.0f, 0.0f, 0.0f, 1.0f);
			gfx_clear_color_set(clear_color);

			array_set_3(point_light_colors[0], 0.1f, 0.1f, 0.1f);
			array_set_3(point_light_colors[1], 0.1f, 0.1f, 0.1f);
			array_set_3(point_light_colors[2], 0.1f, 0.1f, 0.1f);
			array_set_3(point_light_colors[3], 0.3f, 0.1f, 0.1f);

			// Directional light
			gfx_shader_vec3_set_values(lighting_shader, "dir_light.direction", -0.2f, -1.0f, -0.3f);
			gfx_shader_vec3_set_values(lighting_shader, "dir_light.ambient", 0.0f, 0.0f, 0.0f);
			gfx_shader_vec3_set_values(lighting_shader, "dirLight.diffuse", 0.05f, 0.05f, 0.05f);
			gfx_shader_vec3_set_values(lighting_shader, "dirLight.specular", 0.2f, 0.2f, 0.2f);
			// Point light 1
			gfx_shader_vec3_set_values(lighting_shader, "point_lights[0].position", point_lights_positions[0][0], point_lights_positions[0][1], point_lights_positions[0][2]);
			gfx_shader_vec3_set_values(lighting_shader, "point_lights[0].ambient", point_light_colors[0][0] * 0.1f, point_light_colors[0][1] * 0.1f, point_light_colors[0][2] * 0.1f);
			gfx_shader_vec3_set_values(lighting_shader, "point_lights[0].diffuse", point_light_colors[0][0], point_light_colors[0][1], point_light_colors[0][2]);
			gfx_shader_vec3_set_values(lighting_shader, "point_lights[0].specular", point_light_colors[0][0], point_light_colors[0][1], point_light_colors[0][2]);
			gfx_shader_float_set(lighting_shader, "point_lights[0].constant", 1.0f);
			gfx_shader_float_set(lighting_shader, "point_lights[0].linear", 0.14f);
			gfx_shader_float_set(lighting_shader, "point_lights[0].quadratic", 0.07f);
			// Point light 2
			gfx_shader_vec3_set_values(lighting_shader, "point_lights[1].position", point_lights_positions[1][0], point_lights_positions[1][1], point_lights_positions[1][2]);
			gfx_shader_vec3_set_values(lighting_shader, "point_lights[1].ambient", point_light_colors[1][0] * 0.1f, point_light_colors[1][1] * 0.1f, point_light_colors[1][2] * 0.1f);
			gfx_shader_vec3_set_values(lighting_shader, "point_lights[1].diffuse", point_light_colors[1][0], point_light_colors[1][1], point_light_colors[1][2]);
			gfx_shader_vec3_set_values(lighting_shader, "point_lights[1].specular", point_light_colors[1][0], point_light_colors[1][1], point_light_colors[1][2]);
			gfx_shader_float_set(lighting_shader, "point_lights[1].constant", 1.0f);
			gfx_shader_float_set(lighting_shader, "point_lights[1].linear", 0.14f);
			gfx_shader_float_set(lighting_shader, "point_lights[1].quadratic", 0.07f);
			// Point light 3
			gfx_shader_vec3_set_values(lighting_shader, "point_lights[2].position", point_lights_positions[2][0], point_lights_positions[2][1], point_lights_positions[2][2]);
			gfx_shader_vec3_set_values(lighting_shader, "point_lights[2].ambient", point_light_colors[2][0] * 0.1f, point_light_colors[2][1] * 0.1f, point_light_colors[2][2] * 0.1f);
			gfx_shader_vec3_set_values(lighting_shader, "point_lights[2].diffuse", point_light_colors[2][0], point_light_colors[2][1], point_light_colors[2][2]);
			gfx_shader_vec3_set_values(lighting_shader, "point_lights[2].specular", point_light_colors[2][0], point_light_colors[2][1], point_light_colors[2][2]);
			gfx_shader_float_set(lighting_shader, "point_lights[2].constant", 1.0f);
			gfx_shader_float_set(lighting_shader, "point_lights[2].linear", 0.22f);
			gfx_shader_float_set(lighting_shader, "point_lights[2].quadratic", 0.20f);
			// Point light 4
			gfx_shader_vec3_set_values(lighting_shader, "point_lights[3].position", point_lights_positions[3][0], point_lights_positions[3][1], point_lights_positions[3][2]);
			gfx_shader_vec3_set_values(lighting_shader, "point_lights[3].ambient", point_light_colors[3][0] * 0.1f, point_light_colors[3][1] * 0.1f, point_light_colors[3][2] * 0.1f);
			gfx_shader_vec3_set_values(lighting_shader, "point_lights[3].diffuse", point_light_colors[3][0], point_light_colors[3][1], point_light_colors[3][2]);
			gfx_shader_vec3_set_values(lighting_shader, "point_lights[3].specular", point_light_colors[3][0], point_light_colors[3][1], point_light_colors[3][2]);
			gfx_shader_float_set(lighting_shader, "point_lights[3].constant", 1.0f);
			gfx_shader_float_set(lighting_shader, "point_lights[3].linear", 0.14f);
			gfx_shader_float_set(lighting_shader, "point_lights[3].quadratic", 0.07f);
			// SpotLight
			gfx_shader_vec3_set_values(lighting_shader, "spot_light.position", camera.position[0], camera.position[1], camera.position[2]);
			gfx_shader_vec3_set_values(lighting_shader, "spot_light.direction", camera.front[0], camera.front[1], camera.front[2]);
			gfx_shader_vec3_set_values(lighting_shader, "spot_light.ambient", 0.0f, 0.0f, 0.0f);
			gfx_shader_vec3_set_values(lighting_shader, "spot_light.diffuse", 1.0f, 1.0f, 1.0f);
			gfx_shader_vec3_set_values(lighting_shader, "spot_light.specular", 1.0f, 1.0f, 1.0f);
			gfx_shader_float_set(lighting_shader, "spot_light.constant", 1.0f);
			gfx_shader_float_set(lighting_shader, "spot_light.linear", 0.09f);
			gfx_shader_float_set(lighting_shader, "spot_light.quadratic", 0.032f);
			gfx_shader_float_set(lighting_shader, "spot_light.cut_off", cosf(m_radians(10.0f)));
			gfx_shader_float_set(lighting_shader, "spot_light.outer_cut_off", cosf(m_radians(15.0f)));
		}
		break;
		case LOOK_BIOCHEMICAL_LAB:
		{
			array_set_4(clear_color, 0.9f, 0.9f, 0.9f, 1.0f);
			gfx_clear_color_set(clear_color);

			array_set_3(point_light_colors[0], 0.4f, 0.7f, 0.1f);
			array_set_3(point_light_colors[1], 0.4f, 0.7f, 0.1f);
			array_set_3(point_light_colors[2], 0.4f, 0.7f, 0.1f);
			array_set_3(point_light_colors[3], 0.4f, 0.7f, 0.1f);

			// Directional light
			gfx_shader_vec3_set_values(lighting_shader, "dirLight.direction", -0.2f, -1.0f, -0.3f);
			gfx_shader_vec3_set_values(lighting_shader, "dirLight.ambient", 0.5f, 0.5f, 0.5f);
			gfx_shader_vec3_set_values(lighting_shader, "dirLight.diffuse", 1.0f, 1.0f, 1.0f);
			gfx_shader_vec3_set_values(lighting_shader, "dirLight.specular", 1.0f, 1.0f, 1.0f);
			// Point light 1
			gfx_shader_vec3_set_values(lighting_shader, "point_lights[0].position", point_lights_positions[0][0], point_lights_positions[0][1], point_lights_positions[0][2]);
			gfx_shader_vec3_set_values(lighting_shader, "point_lights[0].ambient", point_light_colors[0][0] * 0.1f, point_light_colors[0][1] * 0.1f, point_light_colors[0][2] * 0.1f);
			gfx_shader_vec3_set_values(lighting_shader, "point_lights[0].diffuse", point_light_colors[0][0], point_light_colors[0][1], point_light_colors[0][2]);
			gfx_shader_vec3_set_values(lighting_shader, "point_lights[0].specular", point_light_colors[0][0], point_light_colors[0][1], point_light_colors[0][2]);
			gfx_shader_float_set(lighting_shader, "point_lights[0].constant", 1.0f);
			gfx_shader_float_set(lighting_shader, "point_lights[0].linear", 0.07f);
			gfx_shader_float_set(lighting_shader, "point_lights[0].quadratic", 0.017f);
			// Point light 2
			gfx_shader_vec3_set_values(lighting_shader, "point_lights[1].position", point_lights_positions[1][0], point_lights_positions[1][1], point_lights_positions[1][2]);
			gfx_shader_vec3_set_values(lighting_shader, "point_lights[1].ambient", point_light_colors[1][0] * 0.1f, point_light_colors[1][1] * 0.1f, point_light_colors[1][2] * 0.1f);
			gfx_shader_vec3_set_values(lighting_shader, "point_lights[1].diffuse", point_light_colors[1][0], point_light_colors[1][1], point_light_colors[1][2]);
			gfx_shader_vec3_set_values(lighting_shader, "point_lights[1].specular", point_light_colors[1][0], point_light_colors[1][1], point_light_colors[1][2]);
			gfx_shader_float_set(lighting_shader, "point_lights[1].constant", 1.0f);
			gfx_shader_float_set(lighting_shader, "point_lights[1].linear", 0.07f);
			gfx_shader_float_set(lighting_shader, "point_lights[1].quadratic", 0.017f);
			// Point light 3
			gfx_shader_vec3_set_values(lighting_shader, "point_lights[2].position", point_lights_positions[2][0], point_lights_positions[2][1], point_lights_positions[2][2]);
			gfx_shader_vec3_set_values(lighting_shader, "point_lights[2].ambient", point_light_colors[2][0] * 0.1f, point_light_colors[2][1] * 0.1f, point_light_colors[2][2] * 0.1f);
			gfx_shader_vec3_set_values(lighting_shader, "point_lights[2].diffuse", point_light_colors[2][0], point_light_colors[2][1], point_light_colors[2][2]);
			gfx_shader_vec3_set_values(lighting_shader, "point_lights[2].specular", point_light_colors[2][0], point_light_colors[2][1], point_light_colors[2][2]);
			gfx_shader_float_set(lighting_shader, "point_lights[2].constant", 1.0f);
			gfx_shader_float_set(lighting_shader, "point_lights[2].linear", 0.07f);
			gfx_shader_float_set(lighting_shader, "point_lights[2].quadratic", 0.017f);
			// Point light 4
			gfx_shader_vec3_set_values(lighting_shader, "point_lights[3].position", point_lights_positions[3][0], point_lights_positions[3][1], point_lights_positions[3][2]);
			gfx_shader_vec3_set_values(lighting_shader, "point_lights[3].ambient", point_light_colors[3][0] * 0.1f, point_light_colors[3][1] * 0.1f, point_light_colors[3][2] * 0.1f);
			gfx_shader_vec3_set_values(lighting_shader, "point_lights[3].diffuse", point_light_colors[3][0], point_light_colors[3][1], point_light_colors[3][2]);
			gfx_shader_vec3_set_values(lighting_shader, "point_lights[3].specular", point_light_colors[3][0], point_light_colors[3][1], point_light_colors[3][2]);
			gfx_shader_float_set(lighting_shader, "point_lights[3].constant", 1.0f);
			gfx_shader_float_set(lighting_shader, "point_lights[3].linear", 0.07f);
			gfx_shader_float_set(lighting_shader, "point_lights[3].quadratic", 0.017f);
			// SpotLight
			gfx_shader_vec3_set_values(lighting_shader, "spot_light.position", camera.position[0], camera.position[1], camera.position[2]);
			gfx_shader_vec3_set_values(lighting_shader, "spot_light.direction", camera.front[0], camera.front[1], camera.front[2]);
			gfx_shader_vec3_set_values(lighting_shader, "spot_light.ambient", 0.0f, 0.0f, 0.0f);
			gfx_shader_vec3_set_values(lighting_shader, "spot_light.diffuse", 0.0f, 1.0f, 0.0f);
			gfx_shader_vec3_set_values(lighting_shader, "spot_light.specular", 0.0f, 1.0f, 0.0f);
			gfx_shader_float_set(lighting_shader, "spot_light.constant", 1.0f);
			gfx_shader_float_set(lighting_shader, "spot_light.linear", 0.07f);
			gfx_shader_float_set(lighting_shader, "spot_light.quadratic", 0.017f);
			gfx_shader_float_set(lighting_shader, "spot_light.cut_off", cosf(m_radians(7.0f)));
			gfx_shader_float_set(lighting_shader, "spot_light.outer_cut_off", cosf(m_radians(10.0f)));
		}
		break;
		default:
			break;
		}

		gfx_texture_activate(0);
		gfx_texture_bind(diffuse_map);

		gfx_texture_activate(1);
		gfx_texture_bind(specular_map);

		gfx_vertex_array_bind(cube_va);

		vec3 axis = { 1.0f, 0.3f, 0.5f };
		for (uint i = 0; i < 10; ++i)
		{
			m_mat4_identity(model);
			m_mat4_translate(model, cube_positions[i], model);
			float angle = 20.0f * i;
			m_mat4_rotate(model, m_radians(angle), axis, model);
			gfx_shader_mat4_set(lighting_shader, "model", model);
			gfx_draw_vertices(GFX_VERTEX_TRIANGLE, 36);
		}

		gfx_shader_use(light_cube_shader);
		gfx_shader_mat4_set(light_cube_shader, "projection", projection);
		gfx_shader_mat4_set(light_cube_shader, "view", camera.view);

		gfx_vertex_array_bind(light_cube_va);
		for (uint i = 0; i < 4; ++i)
		{
			m_mat4_identity(model);
			m_mat4_translate(model, point_lights_positions[i], model);
			vec3 scale = { 0.2f, 0.2f, 0.2f };
			m_mat4_scale(model, scale, model);
			gfx_shader_mat4_set(light_cube_shader, "model", model);
			gfx_shader_vec3_set(light_cube_shader, "cube_color", point_light_colors[i]);
			gfx_draw_vertices(GFX_VERTEX_TRIANGLE, 36);
		}

		f_window_swap_buffers(window);
	}

	gfx_shader_delete(lighting_shader);
	gfx_shader_delete(light_cube_shader);
	gfx_vertex_array_delete(cube_va);
	gfx_vertex_array_delete(light_cube_va);
	gfx_vertex_buffer_delete(vertex_buffer);
	gfx_texture_delete(diffuse_map);
	gfx_texture_delete(specular_map);

	f_window_delete(window);
	f_terminate();
	return 0;
}

void resize_callback(AmeWindow* window, uint width, uint height)
{
	if (gfx_context_get() == f_window_context(window))
	{
		gfx_viewport_set_values(0, 0, width, height);
	}
}

void input_callback(AmeWindow* window, const InputEvent* event)
{
	switch (event->type)
	{
	case INPUT_EVENT_KEYBOARD_KEY_DOWN:
	{
		VirtualKey key = f_input_event_key(event);
		switch (key)
		{
		case VIRTUAL_KEY_ESC:
		{
			f_window_send_close(window);
		}
		break;
		case VIRTUAL_KEY_W:
		{
			f_camera_freefly_move(&camera, CAMERA_MOVEMENT_FORWARD, delta_time);
		}
		break;
		case VIRTUAL_KEY_S:
		{
			f_camera_freefly_move(&camera, CAMERA_MOVEMENT_BACKWARD, delta_time);
		}
		break;
		case VIRTUAL_KEY_A:
		{
			f_camera_freefly_move(&camera, CAMERA_MOVEMENT_LEFT, delta_time);
		}
		break;
		case VIRTUAL_KEY_D:
		{
			f_camera_freefly_move(&camera, CAMERA_MOVEMENT_RIGHT, delta_time);
		}
		break;
		default:
			break;
		}
	}
	break;
	case INPUT_EVENT_KEYBOARD_KEY_UP:
	{
		if (f_input_event_key(event) == VIRTUAL_KEY_L)
		{
			++current_look;
			if (current_look == LOOK_BIOCHEMICAL_LAB + 1)
				current_look = LOOK_DESERT;
		}
	}
	break;
	case INPUT_EVENT_MOUSE_WHEEL:
	{
		f_camera_freefly_zoom(&camera, (float)f_input_event_delta(event));
	}
	break;
	case INPUT_EVENT_MOUSE_MOVE:
	{
		int dx;
		int dy;
		f_input_event_move_offset(event, &dx, &dy);
		float x_offset = (float)dx;
		float y_offset = (float)dy;
		f_camera_freefly_look(&camera, x_offset, y_offset);
	}
	break;
	default:
		break;
	}
}</code></pre>
		<h2 id="learn_opengl_-_lighting_2_6_2_multiple_lights_exercise1_lighting_vertex_shader">lighting_vertex_shader</h2>
		<pre><code class="language-glsl">#version 330 core
out vec4 color;

struct Material {
  sampler2D diffuse;
  sampler2D specular;
  float shininess;
};

struct DirLight {
  vec3 direction;
  vec3 ambient;
  vec3 diffuse;
  vec3 specular;
};

struct PointLight {
  vec3 position;
  float constant;
  float linear;
  float quadratic;
  vec3 ambient;
  vec3 diffuse;
  vec3 specular;
};

struct SpotLight {
  vec3 position;
  vec3 direction;
  float cut_off;
  float outer_cut_off;
  vec3 ambient;
  vec3 diffuse;
  vec3 specular;
  float constant;
  float linear;
  float quadratic;
};

#define NUM_POINT_LIGHTS 4

in vec3 frag_normal;
in vec3 frag_pos;
in vec2 tex_coords;

uniform Material material;
uniform vec3 view_pos;
uniform DirLight dir_light;
uniform PointLight point_lights[NUM_POINT_LIGHTS];
uniform SpotLight spot_light;

vec3 calculate_dir_light(DirLight light, vec3 normal, vec3 view_dir);
vec3 calculate_point_light(PointLight light, vec3 normal, vec3 fragment_position, vec3 view_dir);
vec3 calculate_spot_light(SpotLight light, vec3 normal, vec3 fragment_position, vec3 view_dir);

void main()
{
  vec3 norm = normalize(frag_normal);
  vec3 view_d = normalize(view_pos - frag_pos);

  vec3 result = calculate_dir_light(dir_light, norm, view_d);
  for (int i = 0; i < NUM_POINT_LIGHTS; ++i)
    result += calculate_point_light(point_lights[i], norm, frag_pos, view_d);
  result += calculate_spot_light(spot_light, norm, frag_pos, view_d);
  color = vec4(result, 1.0);
}

vec3 calculate_dir_light(DirLight light, vec3 normal, vec3 view_dir)
{
  vec3 light_dir = normalize(-light.direction);
  // diffuse
  float diff = max(dot(normal, light_dir), 0.0);
  // specular
  vec3 reflect_dir = reflect(-light_dir, normal);
  float spec = pow(max(dot(view_dir, reflect_dir), 0.0), material.shininess);
  vec3 ambient = light.ambient * vec3(texture(material.diffuse, tex_coords));
  vec3 diffuse = light.diffuse * diff * vec3(texture(material.diffuse, tex_coords));
  vec3 specular = light.specular * spec * vec3(texture(material.specular, tex_coords));
  return (ambient + diffuse + specular);
}

vec3 calculate_point_light(PointLight light, vec3 normal, vec3 fragment_position, vec3 view_dir)
{
  vec3 light_dir = normalize(light.position - fragment_position);
  // diffuse shading
  float diff = max(dot(normal, light_dir), 0.0);
  // specular shading
  vec3 reflect_dir = reflect(-light_dir, normal);
  float spec = pow(max(dot(view_dir, reflect_dir), 0.0), material.shininess);
  // attenuation
  float distance = length(light.position - fragment_position);
  float attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * (distance * distance));
  vec3 ambient = light.ambient * vec3(texture(material.diffuse, tex_coords));
  vec3 diffuse = light.diffuse * diff * vec3(texture(material.diffuse, tex_coords));
  vec3 specular = light.specular * spec * vec3(texture(material.specular, tex_coords));
  ambient *= attenuation;
  diffuse *= attenuation;
  specular *= attenuation;
  return (ambient + diffuse + specular);
}

vec3 calculate_spot_light(SpotLight light, vec3 normal, vec3 fragment_position, vec3 view_dir)
{
  vec3 light_dir = normalize(light.position - fragment_position);
  // diffuse shading
  float diff = max(dot(normal, light_dir), 0.0);
  // specular shading
  vec3 reflect_dir = reflect(-light_dir, normal);
  float spec = pow(max(dot(view_dir, reflect_dir), 0.0), material.shininess);
  // attenuation
  float distance = length(light.position - fragment_position);
  float attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * (distance * distance));    
  // spotlight intensity
  float theta = dot(light_dir, normalize(-light.direction)); 
  float epsilon = light.cut_off - light.outer_cut_off;
  float intensity = clamp((theta - light.outer_cut_off) / epsilon, 0.0, 1.0);
  vec3 ambient = light.ambient * vec3(texture(material.diffuse, tex_coords));
  vec3 diffuse = light.diffuse * diff * vec3(texture(material.diffuse, tex_coords));
  vec3 specular = light.specular * spec * vec3(texture(material.specular, tex_coords));
  ambient *= attenuation * intensity;
  diffuse *= attenuation * intensity;
  specular *= attenuation * intensity;
  return (ambient + diffuse + specular);
}</code></pre>
		<h2 id="learn_opengl_-_lighting_2_6_2_multiple_lights_exercise1_lighting_fragment_shader">lighting_fragment_shader</h2>
		<pre><code class="language-glsl">#version 330 core
in vec3 pos;
in vec3 normal;
in vec2 uv;

out vec3 frag_normal;
out vec3 frag_pos;
out vec2 tex_coords;

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;

void main()
{
  frag_pos = vec3(model * vec4(pos, 1.0));
  frag_normal = mat3(transpose(inverse(model))) * normal;
  gl_Position = projection * view * vec4(frag_pos, 1.0);
  tex_coords = uv;
}</code></pre>
		<h2 id="learn_opengl_-_lighting_2_6_2_multiple_lights_exercise1_light_cube_vertex_shader">light_cube_vertex_shader</h2>
		<pre><code class="language-glsl">#version 330 core
in vec3 pos;

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;

void main()
{
  gl_Position = projection * view * model * vec4(pos, 1.0);
}</code></pre>
		<h2 id="learn_opengl_-_lighting_2_6_2_multiple_lights_exercise1_light_cube_fragment_shader">light_cube_fragment_shader</h2>
		<pre><code class="language-glsl">#version 330 core
out vec4 color;

uniform vec3 cube_color;

void main()
{
  color = vec4(cube_color, 1.0);
}</code></pre>
	</section>
	<nav class="menu">
		<a href="../index.html">Home</a>
		<a href="cmake.html">cmake</a>
		<a href="ftest.html">ftest</a>
		<a href="math.html">math</a>
		<a href="core.html">core</a>
		<a href="image.html">image</a>
		<a href="graphics.html">graphics</a>
		<a href="util.html">util</a>
		<a href="framework.html">framework</a>
		<a href="documentation.html">documentation</a>
		<a href="learn_opengl_-_getting_started.html">learn_opengl - getting started</a>
		<a href="learn_opengl_-_lighting.html">learn_opengl - lighting</a>
		<a class="section" href="learn_opengl_-_lighting_2_1_colors.html">2_1_colors</a>
		<a class="section" href="learn_opengl_-_lighting_2_2_1_basic_lighting_diffuse.html">2_2_1_basic_lighting_diffuse</a>
		<a class="section" href="learn_opengl_-_lighting_2_2_2_basic_lighting_specular.html">2_2_2_basic_lighting_specular</a>
		<a class="section" href="learn_opengl_-_lighting_2_2_3_basic_lighting_exercise1.html">2_2_3_basic_lighting_exercise1</a>
		<a class="section" href="learn_opengl_-_lighting_2_2_4_basic_lighting_exercise2.html">2_2_4_basic_lighting_exercise2</a>
		<a class="section" href="learn_opengl_-_lighting_2_2_5_basic_lighting_exercise3.html">2_2_5_basic_lighting_exercise3</a>
		<a class="section" href="learn_opengl_-_lighting_2_3_1_materials.html">2_3_1_materials</a>
		<a class="section" href="learn_opengl_-_lighting_2_3_2_materials_exercise1.html">2_3_2_materials_exercise1</a>
		<a class="section" href="learn_opengl_-_lighting_2_4_1_lighting_maps_diffuse_map.html">2_4_1_lighting_maps_diffuse_map</a>
		<a class="section" href="learn_opengl_-_lighting_2_4_2_lighting_maps_specular_map.html">2_4_2_lighting_maps_specular_map</a>
		<a class="section" href="learn_opengl_-_lighting_2_4_3_lighting_maps_exercise2.html">2_4_3_lighting_maps_exercise2</a>
		<a class="section" href="learn_opengl_-_lighting_2_4_4_lighting_maps_exercise4.html">2_4_4_lighting_maps_exercise4</a>
		<a class="section" href="learn_opengl_-_lighting_2_5_1_light_casters_directional.html">2_5_1_light_casters_directional</a>
		<a class="section" href="learn_opengl_-_lighting_2_5_2_light_casters_point.html">2_5_2_light_casters_point</a>
		<a class="section" href="learn_opengl_-_lighting_2_5_3_light_casters_spot.html">2_5_3_light_casters_spot</a>
		<a class="section" href="learn_opengl_-_lighting_2_5_4_light_casters_spot_soft.html">2_5_4_light_casters_spot_soft</a>
		<a class="section" href="learn_opengl_-_lighting_2_6_1_multiple_lights.html">2_6_1_multiple_lights</a>
		<a class="current_section" href="learn_opengl_-_lighting_2_6_2_multiple_lights_exercise1.html">2_6_2_multiple_lights_exercise1</a>
	</nav>
	<footer>
		<p>Another Memory Ends - Reference</p>
	</footer>
</body>
</html>
